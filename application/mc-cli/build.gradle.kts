import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

plugins {
    id("mmm.coffee.lifecycle")
    id("mmm.coffee.java-conventions")
    id("mmm.coffee.versioning")
    id("application")
    id("distribution")
    id("java")
    id("com.github.johnrengelman.shadow") version "8.1.1"
    id("io.freefair.lombok") version "8.0.1"
}

group = "mmm.coffee.metacode"

dependencies {
    // Use this syntax to import a project dependency
    implementation("mmm.coffee.metacode:mc-annotations")
    implementation("mmm.coffee.metacode:mc-common")
    implementation("mmm.coffee.metacode:mc-adapter-spring-spi")
    implementation("mmm.coffee.metacode:mc-generator-spring")
    implementation(libs.picocli)
    implementation(libs.guice)
    implementation(libs.slf4jApi)
    implementation(libs.logbackClassic)
    implementation(libs.vavr)
    implementation(libs.jakartaInject)

    runtimeOnly("mmm.coffee.metacode:mc-adapter-spring-boot")
    runtimeOnly("mmm.coffee.metacode:mc-adapter-spring-batch")
    runtimeOnly("mmm.coffee.metacode:mc-adapter-spring-webmvc")
    runtimeOnly("mmm.coffee.metacode:mc-adapter-spring-webflux")

    testImplementation(platform(libs.junitBillOfMaterial))
    testImplementation(libs.junitJupiter)
    testImplementation(libs.junitSystemRules)
    testImplementation(libs.truth)
    testImplementation(libs.commonsBeanUtils)
    testImplementation(libs.mockito)
    testImplementation(libs.systemLambda)
}


application {
    //mainClass.set("mmm.coffee.zen.cli.CodeZenApplication")
    mainClass.set("mmm.coffee.metacode.cli.Application") // shadowJar needs this syntax
    applicationName = "metacode"
}

/**
 * ToDo: remind me why we're building a shadowJar?
 */
tasks.named<ShadowJar>("shadowJar") {
    archiveBaseName.set(application.applicationName)
    // This wasn't being added before, so not if this line is necessary
    manifest.attributes["Main-Class"] = "mmm.coffee.metacode.cli.Application"
    manifest.attributes["Implementation-Title"] = "MetaCode"
    manifest.attributes["Implementation-Version"] = archiveVersion.getOrElse("0.1")
}

tasks {
    build {
        dependsOn(shadowJar)
        dependsOn(jar)
    }
}

/**
 * ----------------------------------------------------------------
 * When the distribution tar/zip file is the published artifact,
 * a jar is included for each module: the tar/zip file contains
 * a 'lib/meta-annotations-x.y.z.jar, lib/meta-cli-x.y.z.jar,
 * lib/meta-common-x.y.z.jar, and so on. The gist is, there's no
 * primary MANIFEST.MF file like the one found in an uber jar
 * (as generated by shadowjar). PicoCLI expects to find _some_
 * MANIFEST file that reveals the implementation-version of
 * MetaCode. This block creates that MANIFEST file and places it
 * in the meta-cli-x.y.z.jar's manifest.
 * ---------------------------------------------------------------- */


tasks.named<Jar>("jar") {
    archiveBaseName.set(application.applicationName)
    // This line isn't absolutely necessary in the manifest, but it's nice to know.
    // manifest.attributes["Main-Class"] = "mmm.coffee.metacode.cli.Application"
    manifest.attributes["Implementation-Title"] = "MetaCode"
    manifest.attributes["Implementation-Version"] = archiveVersion.getOrElse("0.1")
}


sonar {
    properties {
        property("sonar.projectName", "metacode-cli")
        property("sonar.projectKey", "mmm.coffee.metacode:mc-cli")
    }
}


